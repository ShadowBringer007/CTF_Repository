# heap 0 WriteUp

First I connected to the program to identify what we are supposed to do. It looks like an overflow problem where we need to fill the buffer to do something.</br>
![image](https://github.com/ShadowBringer007/CTF_Repository/assets/47370367/9b8f8702-3f30-48c0-b0f9-71e062bf2ec1)</br>
</br>

Now looking at the source code there is a check_win() function checking to see is the variable "safe_var" contains "bico". Another section which stands out is the init() function in main().</br>
![image](https://github.com/ShadowBringer007/CTF_Repository/assets/47370367/a93b5d3a-03c1-4c72-a67f-39e4f0831911)</br>
![image](https://github.com/ShadowBringer007/CTF_Repository/assets/47370367/f4985cbd-88fe-40d4-9ca9-948f7fad0c6a)</br>
</br>

Analyzing the init() function, two variables are alloacted memory "input_data" and "safe_var". With them being allocated back-to-back, it is safe to assume that we can possible overflow the data in "safe_var".
![image](https://github.com/ShadowBringer007/CTF_Repository/assets/47370367/b5a8c116-09e6-4cf5-a4c2-281a1df3424b)</br>
</br>

Looking at the function where we can input data write_buffer() function. The way this program is doing user input is with scanf() function. This function is vulnerable as it does not check in there is too much data being inputted.</br>
![image](https://github.com/ShadowBringer007/CTF_Repository/assets/47370367/619b346a-f713-49f7-8043-e94c5d0b4cd3)</br>
</br>

Now knowing this we can continously put test data until "safe_var" value gets over written with the 2nd choice and use the third option to see if "safe_var" has changed.</br>
![image](https://github.com/ShadowBringer007/CTF_Repository/assets/47370367/7c94a36b-533c-4e1b-84ad-fe5fd8372046)</br>
</br>

And with placing 32 characters followed by anything, we are able to overwrite the data in "safe_var" and run the check_win() function to print the flag.</br>
![image](https://github.com/ShadowBringer007/CTF_Repository/assets/47370367/639784d6-a54e-4f77-a24e-394699581329)</br>
